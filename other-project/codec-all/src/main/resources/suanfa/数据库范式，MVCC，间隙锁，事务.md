范式：
1、 同一个表中属性不能再分（不能有子属性）
2、 同一个表中要选择 主关键字，其他属性列要完全依赖于这个主关键字， 不能存在仅仅依赖关键字的一部分属性。
3、 取消传递依赖。



myslq 主从模式
        原理：备库复制主库的binlog 然后执行
        
        延迟问题：如果代码逻辑中有 刚insert一条语句，马上 select。那么在高并发情况下，从库可能查不出来。 明显的 主库更新order状态。 从库发现order还是之前状态。
                 解决方法： 1、 分库，降低单库的并发，提升binlog的童虎速度。
                          2、 打开并行复制， 多个库同时复制。
                          3、 代码上注意，避免立即读取刚写入的数据。
        


        mvcc  multiversion concurrency control
        
        http://www.cnblogs.com/chenpingzhao/p/5065316.html
        https://liuzhengyang.github.io/2017/04/18/innodb-mvcc/
        
        
对于MVCC的总结
上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本，这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：
每行数据都存在一个版本，每次数据更新时都更新该版本
修改时Copy出当前版本随意修改，各个事务之间无干扰
保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）
就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，而Innodb的实现方式是：
事务以排他锁的形式修改原始数据
把修改前的数据存放于undo log，通过回滚指针与主数据关联
修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）
二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ 
 
Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。
 
比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。
 
理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。        